{"meta":{"title":"sing's blog","subtitle":"","description":"","author":"Sing","url":"https://singingxy.github.io","root":"/"},"posts":[{"tags":[{"name":"ssh","slug":"ssh","permalink":"https://singingxy.github.io/tags/ssh/"},{"name":"Git","slug":"Git","permalink":"https://singingxy.github.io/tags/Git/"},{"name":"Github","slug":"Github","permalink":"https://singingxy.github.io/tags/Github/"}],"title":"使用ssh连接Git仓库(Github\\GitLab\\CODING\\码云等)","date":"2019/12/23","text":"总的说主要操作是在本地生成 ssh Key，然后把 ssh Key 添加到 Github/GitLab 的账户上，完成连接。 检查现有 ssh 密钥打开 Git Bash 终端。 输入 ls -al ~/.ssh 查看是否已经存在 ssh 密钥： \\$ ls -al ~/.ssh 如果提示不存在此目录那么就来生成新 ssh 密钥 如果已经存在 ssh 密匙文件应该是长下面这个样子： id_rsa.pubid_ecdsa.pubid_ed25519.pub就可以跳过创建 SSH 密钥这一步啦。 生成新 ssh 密钥打开 Git Bash 终端输入ssh-keygen -t rsa -C &lt;your_email@example.com&gt;( 你的邮箱) ssh-keygen -t rsa -b 4096 -C &lt;your_email@example.com&gt; # Creates a new ssh key, using the provided email as a label # Generating public/private rsa key pair. Enter file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter] //enter使用默认地址， 如果需要使用多个Git仓库可以重命名 Enter passphrase (empty for no passphrase): //这里点击 Enter 键即可，也可以填写密码，填写密码后每次使用 ssh 方式推送代码时都会要求输入密码 成功之后显示如下信息： Your identification has been saved in /Users/you/.ssh/id_rsa. # Your public key has been saved in /Users/you/.ssh/id_rsa.pub. # The key fingerprint is: # 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 给账户添加 ssh到路径/Users/用户名/.ssh/下，使用编辑器打开刚刚创建的id_rsa.pub文件，复制下整段内容。打开 Github\\GitLab\\CODING\\码云 的账户设置，找到设置 ssh 的选项，点击新增 ssh 密钥。由于各网站的设置位置都有不同，就不一一详说了。把刚刚复制的 Key 粘贴进去，可以起一个方便你分辨的名字。然后会提示你输入密码，输入完毕后 ssh Key 就添加成功了。 测试 ssh 连接在 Git Bash 里使用命令ssh -T git@github.com测试 ssh 连接，如果是 GitLab 则是ssh -T git@gitlab.com，其他账户同理。 ssh -T git@github.com &gt; The authenticity of host 'github.com (IP ADDRESS)' can't be established. &gt; RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8. &gt; Are you sure you want to continue connecting (yes/no)? //输入 yes &gt; Hi username! You've successfully authenticated, but GitHub does not &gt; provide shell access. 收到欢迎消息说明连接成功。 使用 VS Code 尝试同步把要用的仓库 clone 到本地，放进 vscode 工作区，修改一些内容，可以看到改动的内容被识别出来了。push 一下试试，输入用户名密码，成功。如果密码输错了可以修改凭据 如何修改本地提交时记录的密码控制面板-用户账户-管理 Windows 凭据-找到要修改的那一个，点编辑就可以修改密码了。","permalink":"https://singingxy.github.io/2019/sshKey-Git/","photos":[]},{"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://singingxy.github.io/tags/HTTP/"}],"title":"HTTP请求","date":"2019/12/13","text":"一个完整的 HTTP 请求过程 建立 TCP 连接 Web 浏览器向 Web 服务器发送请求命令 Web 浏览器发送请求头信息 Web 服务器应答 Web 服务器发送应答头信息 Web 服务器向浏览器发送数据 Web 服务器关闭 TCP 连接 HTTP 响应 一个数字和文字组成的状态码，用来显示请求成功还是失败 响应头，响应头也和请求头一样包含许多有用的信息，例如服务器类型、日期时间、内容类型和长度等 响应体，也就是响应正文 HTTP 状态码HTTP 状态码为 3 位数字。 1xx：指示信息 – 表示请求已接收，继续处理。 2xx：成功 – 表示请求已被成功接收、理解、接受。 3xx：重定向 – 要完成请求必须进行更进一步的操作。 4xx：客户端错误 – 请求有语法错误或请求无法实现。 5xx：服务器端错误 – 服务器未能实现合法的请求。","permalink":"https://singingxy.github.io/2019/HTTP-request/","photos":[]},{"tags":[{"name":"VS Code","slug":"VS-Code","permalink":"https://singingxy.github.io/tags/VS-Code/"},{"name":"vue-cli","slug":"vue-cli","permalink":"https://singingxy.github.io/tags/vue-cli/"},{"name":"eslint","slug":"eslint","permalink":"https://singingxy.github.io/tags/eslint/"}],"title":"使用vue-cli构建项目 eslint报Expected linebreaks to be 'LF' but found 'CRLF'错误","date":"2019/12/07","text":"使用 vue-cli 构建项目 eslint 报 Expected linebreaks to be ‘LF’ but found ‘CRLF’错误。解决方法：进入.eslintrc.js文件，rules里添加&quot;linebreak-style&quot;: [0, &quot;error&quot;, &quot;windows&quot;],如下 rules: &#123; \"linebreak-style\": [0, \"error\", \"windows\"] &#125;","permalink":"https://singingxy.github.io/2019/Expected-linebreaks-to-be-LF-but-found-CRLF/","photos":[]},{"tags":[{"name":"html5","slug":"html5","permalink":"https://singingxy.github.io/tags/html5/"},{"name":"img","slug":"img","permalink":"https://singingxy.github.io/tags/img/"}],"title":"img标签里的srcset和sizes是什么","date":"2019/12/06","text":"在使用 img 标签时，有几个 Emmet 带的扩展里面有两个属性srcset和sizes，很惭愧这么久都没有怎么了解过它们，今天就来好好看看。 定义简单来说这两个属性用于制作“响应式图像”，srcset属性用于适配屏幕不同的像素密度，sizes属性根据srcset来指定不同的图片尺寸。 srcset 以逗号分隔的一个或多个字符串列表表明一系列用户代理使用的可能的图像。每一个字符串由以下组成： 图像的 URL。 可选地，空格后跟以下规则的其中之一： 一个宽度描述符，是一个正整数，后面跟 w符号。该整数宽度除以sizes属性给出的图像大小来计算得到有效的像素密度，即换算成和 x 描述符等价的值。 一个像素密度描述符，这是一个正浮点数，后面紧跟 x 符号。 如果没有指定源描述符，那它会被指定为默认的 1x。 在相同的srcset属性中混合使用宽度描述符和像素密度描述符时，会导致该值无效。 重复的描述符（比如，两个源 在相同的srcset两个源都是2x）也是无效的。 sizes 表示图像大小的以逗号隔开的一个或多个字符串。每一个资源大小包括： 媒体查询。最后一项不能有，用作 fallback。 一个图像尺寸的值。(可以是px,em或者vw,但不能是百分比噢) 资源尺寸的值被用来指定图像的预期尺寸。当srcset使用w描述符时，用户代理使用当前图像大小来选择srcset中合适的一个图像 URL。 被选中的尺寸影响图像的显示大小（如果没有 CSS 样式被应用的话）。如果没有srcset，或者没值，那么这个sizes属性将不起作用。 用法试验之前说一句，由于 Chrome 会优先选择缓存图片而不是恰好适配的那个，所以推荐用火狐，可以实时预览变化。 话不多说直接看写法, srcset 属性格式：图片地址 宽度描述 w 像素密度描述 x，多个资源之间用逗号分隔。 下面是使用像素密度描述x的例子，浏览器根据当前设备的像素密度来选择相应的图片加载。 &lt;img srcset=\"320.png, 480.png 2x, 640.png 3x\" src=\"640.png\" /&gt; 下面是使用宽度描述w的例子，当浏览器宽度超过 320px 时加载 320.png，宽度超过 480px 时加载 480.png，宽度超过 640px 时加载 640.png。 &lt;img srcset=\"320.png 320w, 480.png 480w, 640.png 640w\" src=\"640.png\" /&gt; 以上用法图片所占的区域大小是固定的，适合显示所占区域一样大小的图片。那么如果需要在不同屏幕大小下使用不同尺寸的图片，就需要配合sizes属性来使用。 sizes 属性格式：媒体查询 宽度描述（支持 px），多条规则用逗号分隔。下面例子浏览器宽度小于 320px 时图片宽度为 100vw，浏览器宽度小于 480px 时图片宽度为 50vw，其他情况图片宽度为 20vw &lt;img srcset=\"320.png 320w, 480.png 480w, 640.png 640w\" sizes=\"(max-width: 320px) 100vw,(max-width: 480px) 50vw, 20vw\" src=\"640.png\" /&gt; 要注意，sizes属性必须与srcset属性搭配使用，单独使用无效。","permalink":"https://singingxy.github.io/2019/srcset-size/","photos":[]},{"tags":[{"name":"VS Code","slug":"VS-Code","permalink":"https://singingxy.github.io/tags/VS-Code/"},{"name":"编码","slug":"编码","permalink":"https://singingxy.github.io/tags/%E7%BC%96%E7%A0%81/"}],"title":"如何让VS Code按照文件原本编码打开文件","date":"2019/11/30","text":"VS Code 默认是使用 UTF-8 格式来打开文件的，如果遇到 GBK 或者 gb2312 格式的文件，里面的中文就会变成乱码。一般情况下可以点击下方的UTF-8按钮来做转换，点击后会出现“通过编码重新打开”和“通过编码保存”两个选项，选择相应的编码转换就可以了。 但是如果经常接触到 gbk 或 gb2312 格式的文件，上面的方法未免显得太麻烦，最好是让编辑器应用文件本身的编码来打开文件。 可以依次点文件–首选项–设置来打开设置，然后找到文本编辑器-文件把 Auto Guess Encoding 这一项的勾选上。如果觉得在界面里寻找比较麻烦也可以直接在设置的搜索框里输入AutoGuessEncoding,也可以找到这一项设置。可以看到这一项的功能是打开文件时猜测字符编码，有一定失败的可能。 设置完以后在遇到 gbk 格式的文件就方便多啦。","permalink":"https://singingxy.github.io/2019/VS-Code-encoding/","photos":[]},{"tags":[{"name":"hexo","slug":"hexo","permalink":"https://singingxy.github.io/tags/hexo/"}],"title":"hexo主题文件不能push","date":"2019/11/27","text":"搭这个博的时候发现，hexo 内themes文件夹里我们使用的主题文件是不往云端同步的，在 GitHub 上访问可以看到这样的图标， 是一个无法点击的文件夹。 但是主题里有我自己的配置、自己修改的样式，如果不能同步，岂不是每次 clone 的时候都要重新配？那也太麻烦了。 因为这个是一个 clone 下来的文件，相当于一个独立的仓库，别人的项目我们当然是不能 push 的，所以我们要做的是让这个文件夹脱离当前的状态，变成我们项目内的一个正常文件夹。 把文件夹复制到项目外的位置，然后项目里的文件夹删除，直接剪切也可以，然后 push 一下，可以在 GitHub 里看见主题文件已经被删掉了。 然后把文件夹里的.git删掉，重新把主题文件复制回来，再次 push。 到 GitHub 上看看， 这个文件已经变成一个可以点击的正常文件夹啦。","permalink":"https://singingxy.github.io/2019/hexo-themes-push/","photos":[]},{"tags":[{"name":"Windows10","slug":"Windows10","permalink":"https://singingxy.github.io/tags/Windows10/"},{"name":"内存占用","slug":"内存占用","permalink":"https://singingxy.github.io/tags/%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8/"}],"title":"WIN10开机内存占用过高","date":"2019/11/26","text":"最近两天发现电脑变得很卡，明明什么软件都没有开，内存占用却达到了 80%以上，在此基础上无论是再打开什么软件都会让电脑卡死。 看了任务管理器也没看到什么占用内存的进程，最多的也就占了几十 M 的样子，不至于吧。 在 Windows 管理工具里找到Windows 内存诊断运行，提示重启，等待诊断结束。 开机后发现内存占用降到了 27%，问题解决了。","permalink":"https://singingxy.github.io/2019/WIN10%E5%BC%80%E6%9C%BA%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98/","photos":[]},{"tags":[{"name":"hexo","slug":"hexo","permalink":"https://singingxy.github.io/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"https://singingxy.github.io/tags/blog/"}],"title":"来用hexo和GitHub Pages做个个人博客吧","date":"2019/11/25","text":"为什么选 hexoGitHub Pages 的配置页面里推荐了 Jekyll，本来打算就从 Jekyll 开始摸索的，去主页看了文档，需要 Ruby 和 RubyGems ，光是下载 Ruby 这一步就把我卡住了，下载速度为 0。行吧。只能把目光转向了 hexo，一看环境只需要 node.js，用 npm 直接安装就可以，太方便了。 开始安装先把 hexo 装上 npm install -g hexo-cli 然后用 init 初始化 hexo init &lt;folder&gt; cd &lt;folder&gt; npm install 别看就这么短短 3 句话，也有的折腾的。init 这一步由于要下载一个默认的主题包，文件还不小，下了一会儿速度就变 0 了，继续等，结果直接超时了，报了一堆错，基本就是说下载失败什么的。只能重新开始又下了一遍，耐心等待，这回终于成功了。 _config.yml是配置文件，自定义的属性就在里面设置。 部署到 GitHub Pages到_config.yml文件里拉到最下面找到 deploy 配置： deploy: type: git repo: https://github.com/singingXY/singingXY.github.io.git branch: master 填上自己的仓库地址和分支名就可以使用了。 发出第一篇文章下面是几个常用的命令，步骤是：新建文章-生成-本地预览-部署到线上 hexo n \"xxx\" == hexo new \"xxx\" #新建文章 hexo g == hexo generate #生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy #部署 除了上面的写法，我们在自动生成的package.json文件里可以看到如下配置， \"scripts\": &#123; \"build\": \"hexo generate\", \"clean\": \"hexo clean\", \"deploy\": \"hexo deploy\", \"server\": \"hexo server\" &#125; 习惯 npm 的也可以用npm run的形式写。 使用另一个分支保存源码由于master分支里保存的是我们生成出来的文件，而源码是存在本地的，为了当我换一台电脑也能继续更新，我需要把源码存到 github 里，所以新建了一个hexo分支，把源码存在里面。这样当我源码有改动时也能同步更新了。 开始写文章啦当我们执行hexo new的命令后，会在 source 文件夹下看到我们新建的.md文件，顶端以---分隔的区域，叫做 Front-matter，我们可以在里面配置这篇文章的信息。如果要给文章添加 tags 和分类，可以如下设置 categories: - Diary tags: - PS3 - Games Front-matter 的下面就可以开始用 markdown 的语法写文章了。 使用本地图片插件 hexo-asset-image先将_config.yml的post_asset_folder改为 true，然后运行以下命令： npm install https://github.com/CodeFalling/hexo-asset-image --save 这样可以解决在使用本地图片时，本地图片和线上图片路径不一致的问题，本地预览时也可以显示出图片。而且不用把分散的文章里的图片都放在一个总的 source 文件夹内，而是按照文章目录来放置，简单明了。","permalink":"https://singingxy.github.io/2019/%E6%9D%A5%E7%94%A8hexo%E5%92%8CGitHub%20Pages%E5%81%9A%E4%B8%AA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%90%A7/","photos":[]},{"tags":[],"title":"Hello World","date":"2019/11/25","text":"突发奇想搭了一个 blog。以后用来记一下自己遇到和解决的问题吧，与其放在脑子里渐渐忘掉不如写下来作为纪念。","permalink":"https://singingxy.github.io/2019/hello-world/","photos":[]}]}